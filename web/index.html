<!DOCTYPE html>
<html lang="en">

    <!-- asdfadsfasdf -->
<head>
    <meta charset="UTF-8">
    <title>一键转换 Caffe, ONNX, TensorFlow 到 NCNN, MNN, Tengine</title>
    <meta name="Description" content="网页一键将 Caffe ONNX TensorFlow 转为 NCNN, MNN, Tengine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- import CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-ui@2.11.1/lib/theme-chalk/index.css">
</head>
<div style="display:none">
    <script type="text/javascript" src="https://s5.cnzz.com/z_stat.php?id=1277797637&web_id=1277797637"></script>
</div>
<style>
    .content {
        max-width: 500px;
        margin: auto;
    }
    .el-footer {
        /* background-color: #B3C0D1; */
        color: #333;
        text-align: right;
        line-height: 60px;
        font-size: 15px;
    }
</style>


<script>
    function baseName(str)
    {
           var base = new String(str).substring(str.lastIndexOf('/') + 1); 
        if(base.lastIndexOf(".") != -1)       
            base = base.substring(0, base.lastIndexOf("."));
       return base;
    }

    function getConvertedMnnModelUrls(ctx) {
        let _get_buffer1 = Module.cwrap('get_buffer1', "number", ["number"])
        let _get_buffer_size1 = Module.cwrap('get_buffer_size1', "number", ["number"])
        bufferOffset1 = _get_buffer1(ctx);
        bufferSize1 = _get_buffer_size1(ctx);
        output1 = new Uint8Array(HEAP8.subarray(bufferOffset1, bufferOffset1 + bufferSize1));
        let url1 = createObjectURL(output1)
        return [url1];
    }

    function getConvertedModelsAndErrorMsg(ctx) {
        let _get_buffer1 = Module.cwrap('get_buffer1', "number", ["number"])
        let _get_buffer2 = Module.cwrap('get_buffer2', "number", ["number"])
        let _get_buffer3 = Module.cwrap('get_buffer3', "number", ["number"])
        let _get_buffer_size1 = Module.cwrap('get_buffer_size1', "number", ["number"])
        let _get_buffer_size2 = Module.cwrap('get_buffer_size2', "number", ["number"])
        let _get_buffer_size3 = Module.cwrap('get_buffer_size3', "number", ["number"])
        bufferOffset1 = _get_buffer1(ctx);
        bufferSize1 = _get_buffer_size1(ctx);
        console.log("size1 " + bufferSize1);
        output1 = new Uint8Array(HEAP8.subarray(bufferOffset1, bufferOffset1 + bufferSize1));
        bufferOffset2 = _get_buffer2(ctx);
        bufferSize2 = _get_buffer_size2(ctx);
        console.log("size2 " + bufferSize2);
        output2 = new Uint8Array(HEAP8.subarray(bufferOffset2, bufferOffset2 + bufferSize2));

        bufferOffset3 = _get_buffer3(ctx);
        bufferSize3 = _get_buffer_size3(ctx);

        console.log(bufferSize3);
        output3 = new Uint8Array(HEAP8.subarray(bufferOffset3, bufferOffset3 + bufferSize3));
        output3 = String.fromCharCode.apply(null, output3);

        return [output1, output2, output3];
    }

    function getErrorMsg(ctx) {
        let _get_buffer = Module.cwrap('get_buffer3', "number", ["number"])
        let _get_buffer_size = Module.cwrap('get_buffer_size3', "number", ["number"])
        bufferOffset = _get_buffer(ctx);
        bufferSize = _get_buffer_size(ctx);
        output = new Uint8Array(HEAP8.subarray(bufferOffset, bufferOffset + bufferSize));
        const str = String.fromCharCode.apply(null, output);

        return str;
    }

    function transferToHeap(ui8a) {
        heapSpace = Module._malloc(ui8a.length *
            ui8a.BYTES_PER_ELEMENT); // 1
        Module.HEAP8.set(ui8a, heapSpace); // 2 
        return heapSpace;
    }

    function transferToHeapInt32(arr) {
        heapSpace = Module._malloc(arr.length *
            arr.BYTES_PER_ELEMENT); // 1
        Module.HEAP32.set(arr, heapSpace / arr.BYTES_PER_ELEMENT); // 2 
        return heapSpace;
    }

    const readFileAsArrayBuffer = (inputFile) => {
        const temporaryFileReader = new FileReader();

        return new Promise((resolve, reject) => {
            temporaryFileReader.onerror = () => {
                temporaryFileReader.abort();
                reject(new DOMException("Problem parsing input file."));
            };

            temporaryFileReader.onload = () => {
                resolve(temporaryFileReader.result);
            };
            temporaryFileReader.readAsArrayBuffer(inputFile);
        });
    };

    const cpp_js_wrapper_core = (export_name, uint8_arrs, extra_args, extra_types, free=false) => {
        var ctx = Module.ccall('create_exporter', 'number');
        var args = [ctx];
        var arg_types = ["number"];
        const n = uint8_arrs.length;
        for (var i = 0; i < n; i++) {
            const arr = uint8_arrs[i];
            const arr_heap = transferToHeap(arr);
            args.push(arr_heap, arr.length);
            arg_types.push("array", "number");
        }
        const n2 = extra_args.length;
        for (var i = 0; i < n2; i++) {
            args.push(extra_args[i]);
            arg_types.push(extra_types[i]);
        }
        const convert = Module.cwrap(export_name, arg_types);
        const success = convert.apply(null, args);
        if (success) {
            ret = getConvertedModelsAndErrorMsg(ctx);
        } else {
            ret = getErrorMsg(ctx);
        }
        return [success, ret, ctx];
    }

    const files_to_uint8_arrs = async (files) => {
        const n = files.length;
        if (n == 2) {
            var swap = false;
            const filename0 = files[0].name;
            const filename1 = files[1].name;
            const size0 = files[0].size;
            const size1 = files[1].size;
            const format = vm.inputFromat;
            if (filename0.substring(filename0.length - 11) == '.caffemodel' && format == 'caffe') {
                swap = true;
            } else if (filename0.substring(filename0.length - 4) == '.bin' && format == 'ncnn') {
                swap = true;
            } else if ((filename0.substring(filename0.length - 6) == '.param' || filename0.substring(filename0.length - 7) == '.params') && format == 'mxnet') {
                swap = true;
            } else if (filename1.substring(filename1.length - 4) == '.cfg' && format == 'darknet') {
                swap = true;
            } else if (filename1.substring(filename1.length - 11) == '.caffemodel' && format == 'caffe') {
                swap = false;
            } else if (filename1.substring(filename1.length - 4) == '.bin' && format == 'ncnn') {
                swap = false;
            } else if ((filename1.substring(filename1.length - 6) == '.param' || filename1.substring(filename1.length - 7) == '.params') && format == 'mxnet') {
                swap = false;
            } else if (filename0.substring(filename0.length - 4) == '.cfg' && format == 'darknet') {
                swap = false;
            } else if (size0 > 1024 * 1024 && size1 < 512 * 1024) {
                swap = true;
            }
            if (swap) {
                tmp = files[0];
                files[0] = files[1];
                files[1] = tmp;
            }
        }

        var uint8_arrs = []
        for (var i = 0; i < n; i++) {
            const arr = await readFileAsArrayBuffer(files[i]);
            const arr_ui8a = new Uint8Array(arr);
            uint8_arrs.push(arr_ui8a);
        }
       return uint8_arrs;
   }

    const cpp_js_wrapper = async (export_name, files, extra_args, extra_types) => {

        const uint8_arrs = await files_to_uint8_arrs(files);

        const tmp = cpp_js_wrapper_core(export_name, uint8_arrs, extra_args, extra_types);
        [success, ret, ctx] = tmp;

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);

        return [success, ret];
    };

    const ncnnoptimize_js = async (files, fp16) => {
        const export_name = 'ncnnoptimize_export';
        return cpp_js_wrapper(export_name, files, [fp16], ['bool']);
    }

    const onnxsim_js = async (files, optimize) => {
        var uint8_arrs = await files_to_uint8_arrs(files);
        var ctx = Module.ccall('create_exporter', 'number');
        var args = [ctx];
        var arg_types = ["number"];
        const n = uint8_arrs.length;
        for (var i = 0; i < n; i++) {
            const arr = uint8_arrs[i];
            const arr_heap = transferToHeap(arr);
            args.push(arr_heap, arr.length);
            arg_types.push("array", "number");
        }
       splittedShape = [];
       if (vm.showShapeInputBox) {
           splittedShape = vm.shapeTxtFromUser.split(" ").map(x=>parseInt(x));
           if (splittedShape.some(x=>isNaN(x))) {
               return [false, "输入大小格式有误"];
           }
       } else {
            const check = Module.cwrap('check_static_input_size_export', arg_types);
            const tmp = check.apply(null, args);
            if (tmp == 1) {
                Module.ccall('free_exporter', null, ['number'], ctx);
                return ["dynamic", "single"]
            } else if (tmp == -2) {
                Module.ccall('free_exporter', null, ['number'], ctx);
                return ["dynamic", "multi"];
           } else if (tmp == -1) {
                return [false, getErrorMsg(ctx)];
            }
        }
        splittedShape = new Int32Array(splittedShape);
        shapeLen = splittedShape.length;
        splittedShape = transferToHeapInt32(splittedShape);

        const export_name = 'onnxsimplify_export';
        [success, ret, ctx] =  cpp_js_wrapper_core(export_name, uint8_arrs, [optimize, splittedShape, shapeLen], ["bool", "array", "number"]);
        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }

    const onnxoptimize_js = async (files) => {
        const export_name = 'onnxoptimize_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const onnx_shape_infer_js = async (files) => {
        const export_name = 'onnx_shape_infer_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const onnxopt_and_shape_js = async (files) => {
        var uint8_arrs = await files_to_uint8_arrs(files);

        const tmp = cpp_js_wrapper_core('onnxoptimize_export', uint8_arrs, [], []);
       [success, ret, ctx] = tmp;
       if (!success || !(ret[2] === "")) {
            Module.ccall('free_exporter', null, ['number'], ctx);
            return tmp;
       }
       
       [success, ret, ctx] = cpp_js_wrapper_core('onnx_shape_infer_export', [ret[0]], [], [])

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }


    const onnx2ncnn_js = async (files, onnxopt, ncnnopt, fp16) => {
        var uint8_arrs = await files_to_uint8_arrs(files);

        if (onnxopt) {
            tmp = cpp_js_wrapper_core('onnxoptimize_export', uint8_arrs, [], []);
           [success, ret, ctx] = tmp;
           if (!success || !(ret[2] === "")) {
                Module.ccall('free_exporter', null, ['number'], ctx);
                return tmp;
           }
            uint8_arrs = [ret[0]];
        }

        tmp = cpp_js_wrapper_core('onnx2ncnn_export', uint8_arrs, [], []);
       [success, ret, ctx] = tmp;
       if (!success || !(ret[2] === "")) {
            Module.ccall('free_exporter', null, ['number'], ctx);
            return tmp;
       }
       
       if (ncnnopt) {
       [success, ret, ctx] = cpp_js_wrapper_core('ncnnoptimize_export', [ret[0], ret[1]], [fp16], ['bool'])
       }

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }

    const caffe2ncnn_js = async (files, opt, fp16) => {
        var uint8_arrs = await files_to_uint8_arrs(files);

        const tmp = cpp_js_wrapper_core('caffe2ncnn_export', uint8_arrs, [], []);
       [success, ret, ctx] = tmp;
       if (!success || !(ret[2] === "")) {
            Module.ccall('free_exporter', null, ['number'], ctx);
            return tmp;
       }
       
       if (opt) {
           [success, ret, ctx] = cpp_js_wrapper_core('ncnnoptimize_export', [ret[0], ret[1]], [fp16], ['bool'])
       }

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }

    const mxnet2ncnn_js = async (files, opt, fp16) => {
        var uint8_arrs = await files_to_uint8_arrs(files);

        const tmp = cpp_js_wrapper_core('mxnet2ncnn_export', uint8_arrs, [], []);
       [success, ret, ctx] = tmp;
       if (!success || !(ret[2] === "")) {
            Module.ccall('free_exporter', null, ['number'], ctx);
            return tmp;
       }
       
       if (opt) {
           [success, ret, ctx] = cpp_js_wrapper_core('ncnnoptimize_export', [ret[0], ret[1]], [fp16], ['bool'])
       }

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }

    const caffe2mnn_js = async (files) => {
        const export_name = 'caffe2mnn_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const onnx2mnn_js = async (files, opt) => {
        var uint8_arrs = await files_to_uint8_arrs(files);

        if (opt) {
            const tmp = cpp_js_wrapper_core('onnxoptimize_export', uint8_arrs, [], []);
           [success, ret, ctx] = tmp;
           if (!success || !(ret[2] === "")) {
                Module.ccall('free_exporter', null, ['number'], ctx);
                return tmp;
           }
            uint8_arrs = [ret[0]];
        }

       [success, ret, ctx] = cpp_js_wrapper_core('onnx2mnn_export', uint8_arrs, [], [])

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }

    const tf2mnn_js = async (files) => {
        const export_name = 'tf2mnn_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const onnx2tengine_js = async (files, opt) => {
        var uint8_arrs = await files_to_uint8_arrs(files);

        if (opt) {
            const tmp = cpp_js_wrapper_core('onnxoptimize_export', uint8_arrs, [], []);
           [success, ret, ctx] = tmp;
           if (!success || !(ret[2] === "")) {
                Module.ccall('free_exporter', null, ['number'], ctx);
                return tmp;
           }
            uint8_arrs = [ret[0]];
        }

       [success, ret, ctx] = cpp_js_wrapper_core('onnx2tengine_export', uint8_arrs, [], [])

        if (success) {
            ret[0] = createObjectURL(ret[0]);
            ret[1] = createObjectURL(ret[1]);
        }
        Module.ccall('free_exporter', null, ['number'], ctx);
        return [success, ret];
    }

    const caffe2tengine_js = async (files) => {
        const export_name = 'caffe2tengine_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const tf2tengine_js = async (files) => {
        const export_name = 'tf2tengine_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const mxnet2tengine_js = async (files) => {
        const export_name = 'mxnet2tengine_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const darknet2tengine_js = async (files) => {
        const export_name = 'darknet2tengine_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const tflite2tengine_js = async (files) => {
        const export_name = 'tflite2tengine_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    const check_onnx_static_input_shape_js = async (files) => {
        const export_name = 'check_static_input_size_export';
        return cpp_js_wrapper(export_name, files, [], []);
    }

    //
    // create object url
    //
    function createObjectURL(array, type) {
        var useTypedArray = (typeof Uint8Array !== 'undefined');
        var isSafari = (
            navigator.userAgent.indexOf('Safari') !== -1 &&
            navigator.vendor.indexOf('Apple') !== -1
        );
        var data = '';
        var bb;
        var blob;
        var tmp;
        var i;
        var il;

        if (useTypedArray) {
            array = new Uint8Array(array);
        }

        // avoid blob url in safari
        if (!isSafari) {

            // Blob constructor
            try {
                blob = new Blob([array], {type: type});
            } catch (e) {
            }

            // BlobBuilder
            if (
                (tmp = window.WebkitBlobBuilder) !== void 0 ||
                (tmp = window.MozBlobBuilder) !== void 0 ||
                (tmp = window.MSBlobBuilder) !== void 0
            ) {
                bb = new tmp();
                bb.append(array.buffer);
                blob = bb.getBlob(type);
            }

            // createObjectURL
            if (blob && (
                ((tmp = window.URL) && tmp.createObjectURL) ||
                ((tmp = window.webkitURL) && tmp.createObjectURL)
            )) {
                return tmp.createObjectURL(blob);
            }
        }

        // DataURL
        for (i = 0, il = array.length; i < il;) {
            data += String.fromCharCode.apply(
                null,
                useTypedArray ?
                    array.subarray(i, i += 0x7fff) :
                    array.slice(i, i += 0x7fff)
            );
        }

        return 'data:' + type + ';base64,' + window.btoa(data);
    }

</script>
<script src="https://unpkg.com/navigator-languages@2.0.2/dist/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js"></script>
<!-- 引入组件库 -->
<script src="https://unpkg.com/element-ui@2.11.1/lib/index.js"></script>
<script src="https://unpkg.com/vue-i18n@8.9.0/dist/vue-i18n.js"></script>

<div id='app' class='content'>
    <el-container>
        <el-main>
            <el-row type="flex" class="row-bg" justify="center">
                <el-col :span='18'>
                    <div>
                        <h2>
                            {{$t('title1')}}
                            <br/>
                            {{$t('title2')}}
                            <el-tooltip class="item" effect="light"
                                            :content="$t('title_tip')"
                                            placement="top-end">
                                            <i class='el-icon-info'></i>
                                        </el-tooltip>
                        </h2>
                        <div id='choose_output_format'>
                            <font size="4">{{$t('choose_output_format')}}</font><br />
                            <div style="margin-top: 6px">
                                <el-radio-group id='radio' v-model='outputFormat' style="line-height: 20px">
                                    <el-radio label="tengine" style="width:70px">
                                        <font size='3'>tengine</font>
                                    </el-radio>
                                    <el-radio label="ncnn" style="width:60px">
                                        <font size='3'>ncnn</font>
                                    </el-radio>
                                    <el-radio label="mnn">
                                        <font size='3'>mnn</font>
                                    </el-radio>
                                    <el-radio label="onnx">
                                        <font size='3'>onnx</font>
                                        <el-tooltip class="item" effect="light"
                                            :content="$t('onnx_tip')"
                                            placement="top">
                                            <i class='el-icon-info'></i>
                                        </el-tooltip>
                                    </el-radio>
                                </el-radio-group>
                            </div>
                        </div>
                        <div style="margin-top: 15px" id='choose_input_format'>
                            <font size="4">{{$t('choose_input_format')}}</font><br />
                            <div style="margin-top: 6px">
                                <el-radio-group id='radio' v-model="inputFormat" :change='onSelectInputFormat' style="line-height: 20px">
                                    <el-radio label="onnx" style="width:70px">
                                        <font size='3'>onnx</font>
                                    </el-radio>
                                    <el-radio v-if='outputFormat != "onnx"' label="caffe" style="width:60px">
                                        <font size='3'>caffe</font>
                                    </el-radio>
                                    <el-radio v-if='outputFormat == "mnn" || outputFormat == "tengine"' label="tf">
                                        <font size='3'>tensorflow</font>
                                    </el-radio>
                                    <el-radio v-if='outputFormat == "ncnn" || outputFormat == "tengine"' label="mxnet" style="width:70px">
                                        <font size='3'>mxnet</font>
                                    </el-radio>
                                    <el-radio v-if='outputFormat == "tengine"' label="darknet" style="width:60px">
                                        <font size='3'>darknet</font>
                                    </el-radio>
                                    <el-radio v-if='outputFormat == "tengine"' label="tflite">
                                        <font size='3'>tflite</font>
                                    </el-radio>
                                    <el-radio v-if='outputFormat == "ncnn" && outputFormat != "onnx"' label="ncnn">
                                        <font size='3'>ncnn</font>
                                            <el-tooltip class="item" effect="light"
                                                                     :content='$t("ncnn_tip")'
                                                placement="top-end">
                                                <i class='el-icon-info'></i>
                                            </el-tooltip>
                                    </el-radio>
                                </el-radio-group>
                            </div>
                        </div>
                        <div style="margin-top: 15px" id='checkboxes'>
                            <el-checkbox v-if='outputFormat == "onnx"' v-model="onnxSim">{{$t("onnx_sim_checkbox")}}</el-checkbox>
                            <el-checkbox v-if='inputFormat == "onnx"' v-model="onnxOpt">{{$t("onnx_opt_checkbox")}}
                                            <el-tooltip class="item" effect="light"
                                                                     :content='$t("onnx_opt_tip")'
                                                placement="top-end">
                                                <i class='el-icon-info'></i>
                                            </el-tooltip>
                            </el-checkbox>
                            <el-checkbox :disabled='onnxSim && outputFormat == "onnx"' v-if='outputFormat == "onnx"' v-model="onnxInferShape"> {{ $t("onnx_shape_checkbox") }}</el-checkbox>
                            <el-checkbox v-if='outputFormat == "ncnn" && inputFormat != "ncnn"' v-model="ncnnConvertWithOpt">{{ $t("ncnn_opt_checkbox") }}</el-checkbox>
                            <el-checkbox v-if='outputFormat == "ncnn" && (inputFormat == "ncnn" || ncnnConvertWithOpt)' v-model="ncnnoptFp16"> {{ $t("ncnn_fp16_checkbox") }}</el-checkbox>
                        </div>
                        <div style="margin-top: 20px; margin-right: 70px">
                            <el-upload id='select' action="blahblah" ref="select"
                                :on-remove="handleRemove" :on-change="beforeUpload" multiple :limit="dqxlimit"
                                :file-list="fileList" :auto-upload="false">
                                <div slot="tip" class="el-upload__tip">
                                    <font size="2">
                                        {{ uploadTip }}
                                    </font>
                                </div>
                                <el-button slot="trigger" type="primary" :disabled='selectDisabled'> {{ $t("select_button") }} </el-button>
                                <el-button style="margin-left: 30px;" type="success" :disabled='convertDisabled || (outputFormat == "onnx" && !onnxOpt && !onnxInferShape)'
                                                                      @click="submitUpload">{{ $t("convert_button") }}</el-button>
                            </el-upload>
                        </div>
                        <div style="margin-top: 15px" v-if="showShapeInputBox && onnxSim">
                            {{ $t("input_shape_label") }}<el-input style="margin-top: 5px" v-model="shapeTxtFromUser" placeholder=""></el-input>
                        </div>
                        <div style="margin-top: 15px">
                            <div v-if="showWaiting">
                                <font color='#909399'>
                                    <i class='el-icon-info'></i>
                                    {{ $t("converting_text") }}
                                </font>
                            </div>
                            <div v-if='showSuccessMsg'>
                                <font color='#67C23A'>
                                    <i class='el-icon-success'></i>
                                    {{ $t("convert_ok_text") }}
                                </font>
                                <br />
                            </div>
                            <div v-if='showUrls'>
                                <div style="margin-top: 5px">
                                    <el-link type='success' :download='paramFilename' :href='paramUrl'>{{ paramFilename }}</el-link>
                                    <br />
                                    <el-link type='success' :download='binFilename' :href='binUrl' v-if='outputFormat == "ncnn"'>{{ binFilename }}</el-link>
                                </div>
                            </div>
                            <div v-if='showErrorMsg'>
                                <font color='#F56C6C'>
                                    <i class='el-icon-error'></i>
                                    <p v-html="errorMsg"></p>
                                </font>
                            </div>
                        </div>
                    </div>
                </el-col>
            </el-row>
        </el-main>
    </el-container>
    <el-footer>
        Created by <a target="_blank" href="https://github.com/daquexian">daquexian</a>
                                        <el-tooltip class="item" effect="light"
                                            :content="$t('author_tip')"
                                            placement="top-end">
                                            <i class='el-icon-info'></i>
                                        </el-tooltip>
                                        <br/>
                                        <a target="_blank" href="http://www.beian.miit.gov.cn">京ICP备20015268号</a>
    </el-footer>
</div>
<script>
    const messages = {
      en: {
        title1: "Online model conversion",
        title2: "Work out of the box",
          title_tip: "The conversion is performed on your PC. Your model will never be uploaded to the cloud",
          choose_output_format: "Choose output format:",
          choose_input_format: "Choose input format:",
          onnx_tip: "Perform shape inference or optimization by onnx optimizer",
          ncnn_tip: "Use ncnnoptimize to optimize the ncnn model and get better speed",
          onnx_opt_tip: "onnx optimizer is not maintained by onnx team, you can uncheck it if it fails",
          onnx_sim_checkbox: "Simplify the onnx model by onnx-simplifier",
          onnx_opt_checkbox: "Optimize the onnx model by onnx optimizer",
          onnx_shape_checkbox: "Generate model with shape information",
          ncnn_opt_checkbox: "Optimize the ncnn model by ncnnoptimize",
          ncnn_fp16_checkbox: "Generate fp16 model",
          select_button: "Select",
          convert_button: "Convert",
          input_shape_label: "Input shape:",
          converting_text: "Converting...",
          convert_ok_text: "Convert successfully!",
          author_tip: "This webpage itself is create by me, while the conversion is powered by the code from each framework.",
          no_loaded_warning: "Still loading.. Please wait for a mement and try again",
          onnxsim_multiple_dynamic_error: "The model has multiple inputs, among which one input has dynamic shape. This case is not supported.",
          onnxsim_dynamic_msg: 'The model has dynamic-shape input. If the model is only intended to work at a certain input shape, please enter the space-splitted input shape (you might want to check out <a href="https://lutzroeder.github.io/netron/" target="_blank">netron</a> to determine the NCHW or NHWC order) and try again. If not, you might want to use the onnx optmizer instead.',
          ncnn_error_tip: 'Some errors occurs when converting, but sometimes you can still download the model and <a href="https://zhuanlan.zhihu.com/p/93017149" target="_blank">fix manually</a> <br/>',
          unknown_error: 'Unknown error: "{0}", you can try to contact {1} developers',
          unknown_error2: 'Unknown error: "{0}", please contact daquexian',
          please_choose_one_model: "Please select {0} model",
          please_choose_two_models: "Please select {0} and {1} files",
      },
      zh: {
        title1: "省去编译转换工具的时间",
        title2: "开箱即用，一键转换",
          title_tip: "转换是完全由浏览器本身在本地进行的，您的模型不会被上传",
          choose_output_format: "选择目标格式：",
          choose_input_format: "选择输入格式：",
          onnx_tip: "使用 onnx simplifier 和 optimizer 对 onnx 模型进行优化，或对 onnx 模型做 shape inference",
          ncnn_tip: "使用 ncnnoptimize 产生优化后的 ncnn 模型，可以提升速度",
          onnx_opt_tip: "onnx optimizer 已经不被 onnx 团队维护了，如果使用它的时候出现问题可以取消勾选",
          onnx_sim_checkbox: "使用 onnx simplifier 优化模型",
          onnx_opt_checkbox: "使用 onnx optimizer 优化模型",
          onnx_shape_checkbox: "产生有 shape 信息的模型",
          ncnn_opt_checkbox: "使用 ncnnoptimize 优化模型",
          ncnn_fp16_checkbox: "产生 fp16 模型",
          select_button: "选择",
          convert_button: "转换",
          input_shape_label: "输入大小：",
          converting_text: "转换中……",
          convert_ok_text: "转换成功！",
          author_tip: "网页本身是我做的，模型转换部分仍基本使用了原各个框架转换工具的代码，感谢这些框架的作者们~",
          no_loaded_warning: "程序还没有加载完成，请等待一会儿～",
          onnxsim_multiple_dynamic_error: "模型有多个输入并且其中有动态大小的输入，这种情况还不支持",
          onnxsim_dynamic_msg: '模型有动态大小的输入，如果这个模型只想在某一种输入大小下工作，请在文本框里填写以空格分隔的输入大小（请注意各维度的顺序，如 NCHW 和 NHWC，如果不能确定可在 <a href="https://lutzroeder.github.io/netron/" target="_blank">netron</a> 里查看）并重新尝试一次，否则可以仅使用 onnx optimizer 进行优化',
          ncnn_error_tip: '转换遇到了一些错误，不过某些情况下你可以下载模型并 <a href="https://zhuanlan.zhihu.com/p/93017149" target="_blank">手工修复</a> <br/>',
          unknown_error: "遇到了未知错误：“{0}”，可以尝试向 {1} 开发者反馈",
          unknown_error2: "遇到了未知错误：“{0}”，请联系 daquexian",
          please_choose_one_model: "请选择 {0} 模型",
          please_choose_two_models: "请选择 {0} 和 {1} 文件",
      }
    }

    var getNavigatorLanguages = function() {
      if (typeof navigator === 'object') {
        var t = 'anguage', n = navigator, f;
        f = n['l' + t + 's'];
        return f && f.length ? f : (t = n['l' + t] ||
          n['browserL' + t] ||
          n['userL' + t]) ? [ t ] : t;
      }
    };

    const langs = getNavigatorLanguages();
    locale = 'en'
    langs.forEach((x) => { if (x.substring(0, 2) == "zh") { locale = 'zh'; } });

    const i18n = new VueI18n({
      locale:locale, // 设置地区
      messages, // 设置地区信息
    })

    var vm = new Vue({
        i18n,
        el: '#app',
        data: {
            inputFormat: 'onnx',
            outputFormat: 'tengine',
            fileList: [],
            selectDisabled: false,
            convertDisabled: true,
            hasResult: false,
            // Note: In ncnn, there are also converted models 
            // (which can be manually edited) even if the conversion fails.
            // so "convertSuccess" and "hasConvertedModel" are separated.
            convertSuccess: false,
            hasConvertedModel: false,
            ncnnoptFp16: false,
            ncnnConvertWithOpt: true,
            onnxSim: true,
            onnxOpt: true,
            onnxInferShape: true,
            latestFilename: 'model',
            showWaiting: false,
            wasmDownloaded: false,
            showShapeInputBox: false,
            shapeTxtFromUser: '',
        },
        computed: {
            dqxlimit: function () {
                let limit_dict = {
                    'onnx': 1,
                    'caffe': 2,
                    'tf': 1,
                    'ncnn': 2,
                    'mxnet': 2,
                    'darknet': 2,
                    'tflite': 1,
                };
                return limit_dict[this.inputFormat];
            },
            uploadTip: function () {
                const msg_dict = {
                    'onnx': this.$t('please_choose_one_model', ['onnx']),
                    'caffe': this.$t('please_choose_two_models', ['prototxt', 'caffemodel']),
                    'tf': this.$t('please_choose_one_model', ['pb']),
                    'ncnn': this.$t('please_choose_two_models', ['param', 'bin']),
                    'mxnet': this.$t('please_choose_two_models', ['json', 'params']),
                    'darknet':this.$t('please_choose_two_models', ['cfg', 'weight']),
                    'tflite': this.$t('please_choose_one_model', ['tflite']),
                };
                return msg_dict[this.inputFormat];
            },
            showUrls: function () {return this.hasResult && this.hasConvertedModel},
            showErrorMsg: function () {return this.hasResult && !this.convertSuccess},
            showSuccessMsg: function () {return this.hasResult && this.convertSuccess},
        },
        watch: {
            onnxSim: function (newValue, oldValue) {
                if (newValue) {
                    onnxInferShapeBak = this.onnxInferShape;
                    this.onnxInferShape = true;
                } else {
                    this.onnxInferShape = onnxInferShapeBak;
                }
            },
            inputFormat: function (newValue, oldValue) {
                console.log(newValue);
                console.log(this.fileList);
                this.fileList = [];
                this.convertDisabled = this.fileList.length != this.dqxlimit;
                this.selectDisabled = this.fileList.length == this.dqxlimit;
                this.hasResult = false;
                this.showShapeInputBox = false;
            },
            outputFormat: function (newValue, oldValue) {
                this.fileList = [];
                this.hasResult = false;
                this.showShapeInputBox = false;
                this.convertDisabled = this.fileList.length != this.dqxlimit;
                this.selectDisabled = this.fileList.length == this.dqxlimit;
                if ((this.inputFormat == "tf" && (newValue == "tengine" || newValue == "ncnn" || newValue == "onnx")) ||
                (this.inputFormat == "mxnet" && (newValue != "ncnn" && newValue != "tengine")) ||
                (this.inputFormat == "ncnn" && newValue != "ncnn") ||
                (this.inputFormat == "darknet" && newValue != "tengine") ||
                (this.inputFormat == "tflite" && newValue != "tengine")
                ) {
                    this.inputFormat = "onnx";
                }
            },
        },
        methods: {
            submitUpload() {
                if (!this.wasmDownloaded) {
                    this.$message({
                      message: this.$t('no_loaded_warning'),
                      type: 'warning'
                    });
                    return;
                }
                this.hasResult = false;
                this.convertDisabled = true;
                this.showWaiting = true;
                const files = this.$refs.select.uploadFiles.map(file => file.raw);
                const onnx_func_dict = {
                    'onnx': (files) => {
                        if (this.onnxSim) {
                            return onnxsim_js(files, this.onnxOpt);
                        }
                        if (this.onnxOpt && this.onnxInferShape) {
                            return onnxopt_and_shape_js(files);
                        }
                        if (this.onnxOpt) {
                            return onnxoptimize_js(files);
                        }
                        if (this.onnxInferShape) {
                            return onnx_shape_infer_js(files);
                        }
                    },
                };
                const ncnn_func_dict = {
                    'onnx': (files) => { return onnx2ncnn_js(files, this.onnxOpt, this.ncnnConvertWithOpt, this.ncnnoptFp16) },
                    'caffe': (files) => { return caffe2ncnn_js(files, this.ncnnConvertWithOpt, this.ncnnoptFp16); },
                    'mxnet': (files) => { return mxnet2ncnn_js(files, this.ncnnConvertWithOpt, this.ncnnoptFp16); },
                    'ncnn': (files) => { return ncnnoptimize_js(files, this.ncnnoptFp16) },
                    // 'caffe': caffe2mnn_js
                };
                const mnn_func_dict = {
                    'onnx': (files) => { return onnx2mnn_js(files, this.onnxOpt); },
                    'caffe': caffe2mnn_js,
                    'tf': tf2mnn_js,
                };
                const tengine_func_dict = {
                    'onnx': (files) => { return onnx2tengine_js(files, this.onnxOpt); },
                    'caffe': caffe2tengine_js,
                    'tf': tf2tengine_js,
                    'mxnet': mxnet2tengine_js,
                    'darknet': darknet2tengine_js,
                    'tflite': tflite2tengine_js,
                }
                const func_dict = {
                    'ncnn': ncnn_func_dict,
                    'mnn': mnn_func_dict,
                    'tengine': tengine_func_dict,
                    'onnx': onnx_func_dict,
                }
                try {
                const func = func_dict[this.outputFormat][this.inputFormat];
                func(files).then((ret) => {
                    this.convertDisabled = false;
                    this.showWaiting = false;
                    if (ret[0] == "dynamic") {
                        if (ret[1] == "multi") {
                            this.convertSuccess = false;
                            this.errorMsg = this.$t('onnxsim_multiple_dynamic_error');
                            this.hasResult = true;
                            return;
                        } else if (ret[1] == "single") {
                            this.showShapeInputBox = true;
                            this.convertSuccess = false;
                            this.hasResult = true;
                            this.errorMsg = this.$t('onnxsim_dynamic_msg');
                            return;
                        }
                    }
                    this.hasResult = true;
                    const hasModel = ret[0];
                    this.hasConvertedModel = hasModel;
                    this.convertSuccess = hasModel;
                    if (hasModel) {
                        if (this.outputFormat == 'ncnn') {
                            [this.paramUrl, this.binUrl, errorMsg] = ret[1];
                            console.log("js err: " + errorMsg);
                            this.paramFilename = 'ncnn_model.param';
                            this.binFilename = 'ncnn_model.bin';
                            this.paramFilename = latestFilename + (this.ncnnConvertWithOpt ? '-opt' : '') + (this.ncnnoptFp16 ? "-fp16" : "") + '.param'
                            this.binFilename = latestFilename + (this.ncnnConvertWithOpt ? '-opt' : '') + (this.ncnnoptFp16 ? "-fp16" : "") + '.bin'
                            console.log(this.binFilename);
                            if (!(errorMsg === "")) {
                                this.errorMsg = this.$t("ncnn_error_tip") + errorMsg;
                                this.convertSuccess = false;
                            }
                        } else if (this.outputFormat == 'mnn') {
                            [this.paramUrl] = ret[1];
                            this.paramFilename = latestFilename + '.mnn'
                        } else if (this.outputFormat == 'tengine') {
                            [this.paramUrl] = ret[1];
                            this.paramFilename = latestFilename + '.tmfile'
                        } else if (this.outputFormat == 'onnx') {
                            [this.paramUrl] = ret[1];
                            this.paramFilename = latestFilename + (this.onnxSim ? '-sim' : (this.onnxOpt ? '-opt' : '') + (this.onnxInferShape ? "-shape" : "")) + '.onnx'
                        } 
                    } else {
                        this.errorMsg = ret[1];
                        console.log(this.errorMsg);
                    }
                }).catch(err => {
                    this.hasResult = true;
                    const hasModel = false;
                    this.hasConvertedModel = hasModel;
                    this.convertSuccess = hasModel;
                    this.convertDisabled = false;
                    this.showWaiting = false;
                    this.errorMsg = this.$t('unknown_error', [err, this.outputFormat]);
                })
                } catch (err) {
                    this.hasResult = true;
                    const hasModel = false;
                    this.hasConvertedModel = hasModel;
                    this.convertSuccess = hasModel;
                    this.convertDisabled = false;
                    this.showWaiting = false;
                    this.errorMsg = this.$t('unknown_error2', [err]);
                }
            },
            onSelectInputFormat(label) {
                console.log(label);
            },
            beforeUpload(file, fileList) {
                this.selectDisabled = fileList.length == this.dqxlimit;
                this.convertDisabled = fileList.length != this.dqxlimit;
                console.log(file.name);
                latestFilename = baseName(file.name);
            },
            handleRemove(file, fileList) {
                this.selectDisabled = fileList.length == this.dqxlimit;
                this.convertDisabled = fileList.length != this.dqxlimit;
                this.hasResult = false;
                this.showShapeInputBox = false;
            },
        }
    })
</script>

<script>
    var Module = {
        onRuntimeInitialized: function() {
            vm.wasmDownloaded = true;
        }
      };
</script>

<script src="export.js"></script>

</html>
